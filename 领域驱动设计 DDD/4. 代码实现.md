# 代码实现

## 贫血模型

Anemic Domain Mode

领域对象中只有数据，没有行为

面向过程或者过程式编程

## 富领域模型

Rich Domain Model

领域对象里既包含数据，也包含行为。

面向对象或对象式编程

![](https://static001.geekbang.org/resource/image/bd/8f/bda60b4e1d8c6dd181bdbb1e33d6e48f.jpg?wh=3733x2343)

要求：

* 一个是保持代码和模型一致；
* 另一个是符合通用的编程原则和最佳实践。

## 表意接口

Intention-Revealing Interfaces

每个类和方法的命名都应该尽量直观地反映领域知识, 与统一语言保持一致。

## 领域服务

domain service

按照面向对象的做法，领域逻辑本来最好放到领域对象中去，不过有些逻辑又不适合放到领域对象，这时，干脆放到一些只有方法，没有状态的类里面。

## 将业务规则放领域层，并拆分成多个validator

![](https://static001.geekbang.org/resource/image/1d/56/1d6094f0ecf16f6aaed471758312f156.jpg?wh=2900x2018)

## 领域逻辑和应用逻辑

如果一个逻辑需要和领域专家讨论才能确认的，就是领域逻辑；如果领域专家根本不感兴趣的，多半就是应用逻辑。

### 程序模块划分

* 按照类的“性质”
* 按照耦合关系

![](https://static001.geekbang.org/resource/image/d0/04/d09a45e85901474190fafa9918ae4904.jpg?wh=2900x2018)

## 提高应用 API 的封装性

最小接口原则：将一个模块的实现细节尽量隐藏在内部，只向外界暴露最小的可访问接口，也叫信息隐藏原则

## 提高领域对象的封装性

领域对象的封装
哪些属性是不需要修改的，把这些属性变成只读的，从而缩小了对象的接口。

## 编程风格

第一，领域对象不访问数据库。
第二，领域服务只能读数据库。
第三，应用服务可以读写数据库。
第四，用 ID 表示对象之间的关联。
第五，领域对象有自己的领域服务。
第六，在以上前提下利用封装和继承。
