## DDD

### 概念

领域驱动设计（Domain-Driven Design）

软件开发方法论，旨在帮助开发人员更好地理解和解决复杂业务领域中的问题。

### 目的

* 消除信息不对称
* 以业务为主导，自顶向下的进行业务领域划分
* 将大的业务需求进行拆分，分而治之

### 核心思想

* 聚焦于业务领域：DDD 将业务领域视为一个独立的系统，并将软件系统设计为与业务领域保持一致。
* 使用领域模型：领域模型是业务领域的抽象表示，它描述了业务领域中的概念、关系和规则。
* 使用通用语言：通用语言是业务专家和开发人员之间使用的共同语言。它可以帮助开发人员更好地理解业务领域。
* 限界上下文：限界上下文是领域模型的一个子集，它定义了领域模型的边界和职责。
聚合：聚合是具有一致状态和行为的领域模型对象。
领域事件：领域事件是表示在业务领域中发生的变化。

### 架构对比

| 量化维度	| MVC	| DDD|
|  ----  | ----  |----  |
| 分层结构	| 三层结构	| 四层结构 |
| 模型	| 贫血模型	| 充血模型|
| 开发成本| 	前期易构建 中期较难扩展后期复杂化扩展| 	前期构建花费时间中期扩展简单后期支持扩展|
| 学习成本| 	易上手| 	需要领域建模经验|
| 使用场景	| 项目周期短，业务复杂性低	| 项目周期长，业务复杂性高，后续迭代要求高|

### 术语介绍

战略设计：限界上下文、通用语言，子域

战术设计：聚合、实体、值对象、资源库、领域服务、领域事件、模块

### 架构

![](https://static001.geekbang.org/resource/image/5d/ae/5d1e1752b444bc1055867c977d6f71ae.jpg?wh=2900x1714)

* 适配层（adapter）：用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给应用层。
* 应用层（application）：用来表述应用和用户行为，负责服务的组合、编排和转发，负责处理业务用例的执行顺序以及结果的拼装。
* 领域层（domain）：为完成领域中跨实体或值对象的操作转换而封装的服务，领域服务以与实体和值对象相同的方式参与实施过程。
* 基础层：为各层提供资源服务（如数据库、缓存等），实现各层的解耦，降低外部资源变化对业务逻辑的影响。

### 分层请求调用链

## 前端中的领域驱动

### 理解后端领域模型

保证前后端对于业务模型的理解一致

### 建立前端领域模型

前端的领域模型图与后端的领一致程度很高，但绝不是一样的。

### 分离领域层

* 领域层是稳定的（页面以及与页面绑定的模块都是不稳定的）
* 领域层是解耦的（页面是会耦合的，页面的数据会来自多个接口，多个领域）
* 领域层具有极高复杂度，值得单独管理(view层处理页面渲染以及页面逻辑控制，复杂度已经够高，领域层解耦可以轻view层。view层尽可能轻量是我们架构师cnfi主推的思路)
* 领域层以层为单位是可以被复用的（你的代码可能会抛弃某个技术体系，从vue转成react，或者可能会推出一个移动版，在这些情况下，领域层这一层都是可以直接复用）
* 为了领域模型的持续衍进(模型存在的目的是让人们聚焦，聚焦的好处是加强了前端团队对于业务的理解，思考业务的过程才能让业务前进)

### 主导接口约定

### 开发中注意业务含义

### 实时同步

### 文件夹定义

* 顶层文件夹最多包含：assets，pages，layouts，app 四个
* 按功能划分文件夹，每个功能只能包含以下四种文件：Xxx.less, Xxx.tsx, useXxx.ts，useXxx.spec.ts , 采用嵌套结构组织
* 一个文件夹包含该领域内所有逻辑（视图，样式，测试，状态，接口），禁止将逻辑放置于文件夹以外
* 功能结构即文件结构，目录尽可能保持扁平
* 管理上，相关领域文件夹可以分配给专人，开发效率高，可追责和计量工作量，很明显应该禁止多人同时操作同一层级文件

### 遵循 LIFT 原则

* 优先将组件视为元素，而并非功能逻辑单位（视图的归视图，业务的归业务）
* 隔离原则（属于一个成员的工作，必定属于该成员负责的文件夹，也只能属于该成员负责的文件夹）
* 最小依赖（禁止不必要的工具使用，比如当前需求下，引入 Redux/Flux/Dva/Mobx 等工具，并没有解决什么问题，却导致功能更加受限，影响隔离原则比如当两个组件需要服务的不同实例的情况，以上工具属于上个版本或某种特殊需求，比如前后端同构，不能影响这个版本当前需求的架构）
* 优先响应式（普及管道风格的函数式方案，大胆使用 useEffect 等 api，不提倡松散的函数组合，只要是视图所用的数据，必须全部都为响应式数据，并响应变更）
* 测试友好（边界清晰，风格简洁，隔离完整，即为测试友好）
* 设计友好（支持模块化设计）

### 个人想法

DDD 作为一种软件开发方法论，可以帮助开发人员更好地理解和解决复杂业务领域中的问题。他不像之前一些比如 MVC 的模型一样从数据出发进行设计，而是从业务出发，自顶向下，站在解决领域问题的角度去分析和设计系统，同时还可以产生一些业务文档。可以优化从需求拆解，项目架构，代码编写，甚至对最后的测试交付出现的一些问题。

以下是我的一些想法：
对 Tetris 项目来说，随着项目不断迭代，每个人对一些业务概念或需求的定位和理解会存在差异，导致在进行交互设计或者开发过程中常常会遇到一些问题，又需要反复开会讨论甚至改版；对于新同事或是负责不同业务的同事（包括前端，后端，测试），很多概念都是隔离的或者模糊的，对项目中的一些信息并不是很清楚，需要额外花时间询问沟通，影响迭代效率。

对此有以下建议：
* 依据 DDD 的开发模式，组织所有相关人员共同讨论建立领域模型，再进行开发。使包括产品，交互，开发，测试在内的每个人都能理解业务需求和概念，并达成一致，提高迭代效率；
* 完善项目有关文档，包括项目说明文档、技术实现文档、业务规则、接口契约规则等，同时每个人也可以将自己负责的业务或实现方案整理成文档进行分享。这样的话，可以确保团队成员对系统的理解一致，提高团队成员沟通效率和默契，也有助于新成员的快速融入和项目的可持续发展。

但经过一段时间的学习，发现 DDD 课程基本都是在后端环境进行讨论的。据了解 iQualtiy 和 Tetris 的后端项目都使用了 DDD 的架构。作为前端开发人员，在学习过程中难免会有想：前端可以 DDD 么？该怎么设计 DDD。

前端作为需求方、后端、交互、用户的桥梁，在与不同角色进行沟通时，常常需要切换思维和兼容不同情况。同时前端是最靠近用户的一层，在代码中难免会出现一些业务逻辑，甚至有的逻辑只能由前端来完成，随着业务不断增加，有时根本无法区分哪些是业务逻辑，哪些是交互逻辑。在某些方面来说，前端锁关注的内容甚至比后端还大，因此对前端而言，无论是业务方面还是代码实现方面，实施 DDD 的好处可能更多。

依据 DDD 的四层分层模型，同时结合前端的特点，前端在架构上也可以分为：UI 层、控制层、领域层、基础层。同时将代码分层组织，根据领域进行划分管理，从架构思想和代码组织方面，也可以实现前端的 DDD。同时对于多端复用的业务来说，只需要重写 UI 层即可，这个是前端使用 DDD 最大的优势。但由于前端关注的内容的不同，同时各种前端框架和技术的不断更新，包括如何在当前项目和团队内实施，可能还需要做一些准备和讨论。

借用海潮的一句话：DDD 是一种思想工具，应该站在更高的角度去思考和讨论，而不是仅局限于当前技术
