# DDD 领域驱动设计

Domain-Driven Design

一种开发复杂软件的系统化的方法学和思想

## 传统面向对象方法学的问题

在企业应用方面还没有取得成功

* 只重技术，不重业务
* 围绕业务进行开发的方法本身不好学
* 早期面向对象方法学主要考虑的是建模技术，很少考虑协作问题。企业应用多数都是团队作战
* 难以适应变化

## 领域

指的是软件要解决的那些业务问题，所以也可以叫业务领域，Business Domain

## 基本开发过程

![](https://static001.geekbang.org/resource/image/3d/1e/3d591062766dede3e6039e1e0804261e.jpg?wh=2900x1314)

1. 捕获行为需求

分析系统具有哪些功能，这些功能由什么人操作，会产生什么效果。

方式：
* 传统软件工程：用例建模
* DDD：事件风暴

2. 领域建模
   把需求里的主要业务知识描述清楚

3. 架构设计
   进程间和进程内的架构

4. 数据库设计
5. 代码实现

### 事件风暴

Event Storming
一种通过协助完成需求梳理的方法。

使用阶段：捕获行为需求

![](https://static001.geekbang.org/resource/image/ea/1b/ea006b757ab0b2aeff0d888128f9d31b.jpg?wh=3101x1393)

步骤
1. 识别领域事件：找到业务流程中发生了哪些事情
2. 识别命令：是什么角色，做了什么操作，导致上述事情的发生
3. 识别领域名词：从领域事件和命令中找到名词性概念

注意：
* 在事件风暴里只列出**主要的**、足以用于表达和交流领域知识的步骤（比如修改删除，可以省略）
* 各个领域事件按照**大致时间顺序**即可（防止因为出现条件判断让其变得繁琐）
* 每个步骤（领域事件+命令）的颗粒度宜粗不宜细
* 适用于需求不清晰，或者理解不统一时，通常对于新项目或系统大改造。只要解决的问题是需求与业务的一致等问题都可用
* 保存：
  + 事件风暴表（业务流程，命令，领域事件。执行者，查询数据，领域对象）。
  + 领域规则表（规则编号，模块，规则描述，举例，影响的主要功能）

#### 1. 识别领域事件

领域事件：业务流程中每个步骤引发的**结果**（从结果入手来梳理需求，比从操作入手，更容易把业务想清楚）

参与人员：业务和技术人员

步骤：
1. 业务人员和开发人员双方写出自己理解的领域事件。
2. 通过沟通、协助来迭代领域事件，明确业务规则，构建统一语言，最终达成一致的理解。

命名规则：完成时 + 被动语态（订单已提交、商品已签收）。优先使用约定俗成的业务术语

注意：
1. 不要把技术事件当成领域事件
2. 查询功能不算领域事件

![](https://static001.geekbang.org/resource/image/fe/2a/feb7e0e78ffc59c7fba013124b77632a.jpg?wh=3600x2179)

#### 2. 识别命令

命令：引发领域事件的操作

结果：
* 命令本身 command
* 谁执行的命令 actor
* 为了执行命令我们要查询出什么数据

![](https://static001.geekbang.org/resource/image/8d/c8/8d2020e9710a44ff5b92b7cd272f72c8.jpg?wh=3733x1694)

#### 3. 识别领域名词

领域名词：是从命令、领域事件、执行者、查询数据里找到的名词性概念。

步骤：
1. 把围绕同一个名词的命令、事件、执行者、查询数据归类到一起
2. 将领域名词写在大一点的黄色便利贴上，贴在每堆便利贴的中间

如果一个名词在时间和命令中都出现，则在这个名词后加个出现的次数即可。

### 建立领域模型

#### 目的

* **将知识可视化**。准确、深刻地反映领域知识，并且在业务和技术人员之间达成一致；
* **指导系统的设计和编码**。也就是说，领域模型应该能够比较容易地转化成数据库模式和代码实现。

#### 任务

* 识别领域对象（domain object），领域对象之间的关系，
* 识别领域对象的关键属性
* 必要的时候还要将领域对象组织成模块。

领域对象类型：
* 实体（entity）
* 值对象（value object）

#### 工具

用**领域模型图**来表达的，通常用 **UML** 来画
由类和他们之间的关系组成的图叫做类图

* 实体
* 属性：可略，或只写关键属性
* 操作
* 关联关系：一对一`1:1`、一对多 `1:*`、多对多`*:*`、一对0到多`1:0..*`、只能属于一个`1:1..1`
* 注释
* 约束：凡是约束，必须在程序中的某个地方进行实现
* 包：高内聚低耦合的模块
* 依赖：带箭头的虚线，箭头由依赖方指向被依赖方

![](https://static001.geekbang.org/resource/image/yy/5a/yy1970cdbdf03e6a4413bb85fa39bb5a.jpg?wh=3268x2260)

* 可将有共性的实体抽象成一个实体
* 自关联：角色
* 任何多对多关联，总能用类似的方法，通过引入一个表示关联的实体，拆成两个一对多的关联。

#### 包

微观：

![](https://static001.geekbang.org/resource/image/ec/2e/ec0a5fd92c64e10e11cd053b8ac39e2e.jpg?wh=3431x2260)

宏观：

![](https://static001.geekbang.org/resource/image/22/87/22cf84702d9c9cff4518ab4b37e10c87.jpg?wh=2983x1889)

依赖：带箭头的虚线，箭头由依赖方指向被依赖方

### 后续工作

1. 完善业务规则
2. 建立词汇表

![](https://static001.geekbang.org/resource/image/92/0f/92704b55b0a605e9cf29c3992f76d10f.jpg?wh=3245x3105)

## 传统方法与DDD的区别

传统方法建立分析模型强调完全从业务领域出发，不考虑技术视角

DDD 强调领域模型要兼顾业务和技术两个视角

传统方法

![](https://static001.geekbang.org/resource/image/65/fa/65fb4c58375e335f8bdbb9a9e47964fa.jpg?wh=3733x1452)

DDD

![](https://static001.geekbang.org/resource/image/fa/51/fa018dded64563a7746cde52a779b951.jpg?wh=3479x1373)

## DDD 的核心模式

### 模型驱动设计

Model-Driven Design

* 领域模型要和业务需求一致
* 系统实现要和领域模型一致

### 统一语言

Ubiquitous Language

* 建立好领域模型、词汇表等“物质基础”
* 沟通协作的过程中，不断保持模型、语言和系统实现的一致性
